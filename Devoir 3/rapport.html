<html>

    <head>
      <title>IFT3911 DM3</title>
      <style type="text/css">
        table {
          border: outset 2px black;
          border-collapse: collapse;
        }
  
        th {
          border-bottom: double 2px black;
        }
  
        td {
          border-bottom: solid 1px black;
        }
  
        .first_col {
          border-right: double 2px black;
        }
      </style>
      <style>
        body.shimeji-pinned iframe {
          pointer-events: none;
        }
  
        body.shimeji-select-ie {
          cursor: cell !important;
        }
  
        #shimeji-contextMenu::-webkit-scrollbar {
          width: 6px;
        }
  
        #shimeji-contextMenu::-webkit-scrollbar-thumb {
          background-color: rgba(30, 30, 30, 0.6);
          border-radius: 3px;
        }
  
        #shimeji-contextMenu::-webkit-scrollbar-thumb:hover {
          background: #555;
        }
      </style>
    <meta name="shimejiBrowserExtensionId" content="gohjpllcolmccldfdggmamodembldgpc" data-version="2.0.5"></head>
  <body>
      <h1 style="text-align: center;">
          IFT 3911 - Devoir 3 (équipe echo)</h1>
      
      <u><h2>Information générale</h2></u>
      <p>
          <span style="font-weight: bold;">Nom: </span>Simon Voglimacci Stéphanopoli
          <br>
          <span style="font-weight: bold;">Matricule: </span>20002825
          <br>
          <span style="font-weight: bold;">Courriel: </span>simon.voglimacci.stephanopoli@umontreal.ca
          <br>
          <span style="font-weight: bold;">temps mis: </span>10 heures
      </p>
      <p>
          <span style="font-weight: bold;">Nom: </span>Julie Yang
          <br>
          <span style="font-weight: bold;">Matricule: </span>20239909
          <br>
          <span style="font-weight: bold;">Courriel: </span>julie.yang@umontreal.ca
          <br>
          <span style="font-weight: bold;">temps mis: </span>10 heures
      </p>
      <p>
          <span style="font-weight: bold;">Nom: </span>Célina Zhang
          <br>
          <span style="font-weight: bold;">Matricule: </span>20207461
          <br>
          <span style="font-weight: bold;">Courriel: </span>celina.zhang@umontreal.ca
          <br>
          <span style="font-weight: bold;">temps mis: </span>10 heures
      </p>
      <u><h2>Distribution des tâches</h2></u>
      <p>
          <span style="font-weight: bold;">Soumetteur: </span>Célina Zhang
      </p>
      <table cellpadding="7px">
          <thead>
              <tr>
                  <th class="first_col">
                      Tâche
                  </th>
                  <th>
                      Simon
                  </th>
                  <th>
                      Julie
                  </th>
                  <th>
                      Célina
                  </th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td class="first_col">
                    Fabrique 
                  </td>
                  <td>
                     Diagramme de classe
                  </td>
                  <td>
                      Diagramme de sequence
                  </td>
                  <td>
                     Genereration de code 
                  </td>
              </tr>
              <tr>
                  <td class="first_col">
                    Singleton
                  </td>
                  <td>
                    Genereration de code 
                  </td>
                  <td>
                    Diagramme de classe
                  </td>
                  <td>
                    NA
                  </td>
              </tr>
              <tr>
                  <td class="first_col">
                    Etat
                  </td>
                  <td>
                    Diagramme de classe 
                  </td>
                  <td>
                    Diagramme de sequence
                  </td>
                  <td>
                    Genereration de code
                  </td>
              </tr>
              <tr>
                  <td class="first_col">
                      Observateur
                  </td>
                  <td>
                    Diagramme de sequence
                  </td>
                  <td>
                    Diagramme de classe
                  </td>
                  <td>
                    Genereration de code
                  </td>
              </tr>
              <tr>
                  <td class="first_col">
                      Commande
                  </td>
                  <td>
                    Genereration de code
                  </td>
                  <td>
                    Diagramme de sequence
                  </td>
                  <td>
                    Diagramme de classe
                  </td>
              </tr>
              <tr>
                  <td class="first_col">
                      Visiteur
                  </td>
                  <td>
                      Genereration de code
                  </td>
                  <td>
                      Diagramme de classe
                  </td>
                  <td>
                      Diagramme de sequence
                  </td>
              </tr>
              <tr>
                <td class="first_col">
                    Strategie
                </td>
                <td>
                    Genereration de code
                </td>
                <td>
                    NA
                </td>
                <td>
                    Diagramme de classe
                </td>
            </tr>
            <tr>
                <td class="first_col">
                    Memento
                </td>
                <td>
                    NA
                </td>
                <td>
                    Diagramme de classe
                </td>
                <td>
                    Genereration de code
                </td>
            </tr>
            <tr>
                <td class="first_col">
                    Diagramme de paquets
                </td>
                <td>
                    NA
                </td>
                <td>
                    100%
                </td>
                <td>
                    NA
                </td>
            </tr>
          </tbody>
      </table>
      <u><h2>Fabrique</h2></u>
      <p>
          <a href="Design/Factory.vpp" alt="factoryVPP">Diagramme de classe : fabrique</a> <br>
          <img src="images/Factory.jpg" alt="factoryVPPimg">
          <br>
          <a href="Design/FactorySequence.vpp" alt="factorySequenceVPP">Diagramme de sequence : fabrique</a> <br>
          <img src="images/FactorySequence.jpg" alt="factorySequenceVPPimg">
          <br>
          Voici quelques hypothèses et notre raisonnement :
      </p>
      <ul>
          <li>Le patron de fabrique permet de centraliser la création des entités selon le type de transport (Air, Mer, Terre).</li>
          <li>Il permet de déléguer l’instanciation d’objets à des sous-classes, en définissant une interface de création dans la classe abstraite (ou superclasse), tout en laissant les sous-classes décider du type exact d’objet à retourner.</li>
          <li>Ce patron respecte plusieurs principes SOLID, notamment :
            <ul>
                <li>Ouvert/Fermé (Open/Closed Principle) : les classes peuvent être étendues pour créer de nouveaux types d’objets sans modifier les classes existantes.</li>
                <li>Responsabilité unique (Single Responsibility Principle) : la logique de création est séparée de la logique métier, ce qui améliore la lisibilité et la maintenance du code.</li>
            </ul>
          </li>
          <li>Il est particulièrement utile dans les systèmes complexes où plusieurs familles d’objets doivent être créées selon un contexte ou un paramètre (comme ici avec les entités Air, Sea, et Ground). Cela permet de garantir la cohérence au sein de chaque famille tout en offrant une interface uniforme aux clients.</li>
          <li>facilite l'extensibilité du système : l’ajout d’un nouveau type de transport, par exemple SpaceFactory, nécessitera simplement une nouvelle sous-classe de TravelFactory, sans avoir à modifier le code des classes clientes existantes.</li>
      </ul>
  
      <u><h2>Singleton</h2></u>
      <p>
          Voici quelques hypothèses et notre raisonnement :
      </p>
      <ul>
          <li>Le patron Singleton garantit qu'une classe ne possède qu'une seule instance dans le système et fournit un point d'accès global à cette instance.</li>
          <li>Il est particulièrement utile pour gérer des ressources partagées ou centralisées, comme ici avec une fabrique (TravelFactory) utilisée dans tout le système.</li>
          <li>Ce patron est compatible avec le patron de fabrique, car il permet de centraliser la création d’objets tout en s’assurant que toutes les entités passent par la même instance de fabrique.</li>
      </ul>
  
      <u><h2>Etat</h2></u>
      <p>
        <a href="Design/State.vpp" alt="stateVPP">Diagramme de classe : etat</a> <br>
        <img src="images/State.jpg" alt="stateVPPimg">
        <br>
        <a href="Design/StateSequence.vpp" alt="stateSequenceVPP">Diagramme de sequence : etat</a> <br>
        <img src="images/StateSequence.jpg" alt="stateSequenceVPPimg">
        <br>
        Voici quelques hypothèses et notre raisonnement :
    </p>
        <ul>
          <li>Correction du diagramme de classe: setState(reserved: Reserved) devient setState(seatingState: SeatingState)</li>
          <li>Chaque état est représenté par une sous-classe d’une classe abstraite (ou interface) commune (SeatingState ici), ce qui permet d’implémenter des comportements spécifiques pour chaque état (Available, Reserved, Confirmed).</li>
          <li>Le patron suit le principe ouvert/fermé : on peut ajouter de nouveaux états sans modifier les classes existantes.</li>
          <li>Il est particulièrement utile pour éviter les structures conditionnelles complexes (ex: if/else ou switch) dans les méthodes, en déléguant le comportement à l’objet représentant l’état.</li>
          <li>Afin de simplifier le diagramme de séquence, l’« Actor » représente un regroupement conceptuel des classes liées au client et englobe à la fois les actions effectuées par ce dernier ainsi que ses interactions avec le système.</li>
          <li>Il n'y a pas de flêche à Confirmed, car celui est l'état final d'un siège.</li>
          <li>Seating est le context.</li>
          <li>Available, Confirm et Reserved sont les états concrèts.</li>
        </ul>

        <u><h2>Observateur</h2></u>
        <p>
          <a href="Design/Observer.vpp" alt="observerVPP">Diagramme de classe : observateur</a> <br>
          <img src="images/Observer.jpg" alt="observerVPPimg">
          <br>
          <a href="Design/ObserverSequence.vpp" alt="observerSequenceVPP">Diagramme de sequence : observateur</a> <br>
          <img src="images/ObserverSequence.jpg" alt="observerSequenceVPPimg">
          <br>
          Voici quelques hypothèses et notre raisonnement :
      </p>
          <ul>
            <li>Ce patron est utile pour garantir la synchronisation automatique entre les données (dans Repository) et les interfaces utilisateurs (les vues).</li>
            <li>Il se compose généralement de :
                <ul>
                    <li>Un sujet qui maintient une liste d’observateurs (addObserver, removeObserver) et les notifie (notifyObservers()).</li>
                    <li>Une interface Observer avec une méthode update() que chaque observateur implémente.</li>
                    <li>Des observateurs concrets (ici ClientView et AdminView) qui mettent à jour leur affichage ou leur logique en réponse à une notification.</li>
                </ul>
            <li>Il permet de découpler la logique métier de l’interface utilisateur, rendant le système plus modulaire, maintenable et extensible.</li>
            <li>Il y a beaucoup de méthodes qui changent l'état dans Repository (add, delete, edit, ...). Pour simplifier, ces méthodes sont résumées à « change state ».</li>
            <li>Repository est Observable</li>
            <li>ClientView et AdminView sont les observeurs concrèts</li>
          </ul>
    
    <u><h2>Commande</h2></u>
    <p>
        <a href="Design/Command.vpp" alt="commandVPP">Diagramme de classe : commande</a> <br>
        <img src="images/Command.jpg" alt="commandVPPimg">
        <br>
        <a href="Design/CommandSequence.vpp" alt="commandSequenceVPP">Diagramme de sequence : commande</a> <br>
        <img src="images/CommandSequence.jpg" alt="commandSequenceVPPimg">
        <br>
        Voici quelques hypothèses et notre raisonnement :
    </p>
        <ul>
            <li>Il est composé de :</li>
                <ul>
                    <li>Une interface de commande (ICommand) définissant des méthodes comme execute() et undo().</li>
                    <li>Des commandes concrètes qui encapsulent une action spécifique (ex : CreateHubCommand, DeleteCompanyCommand, etc.).</li>
                    <li>Un invocateur (Invoker) qui exécute les commandes et gère un historique pour permettre l’annulation (undo()).</li>
                    <li>Un client (ici AdminController) qui instancie les commandes et les transmet à l’invocateur.</li>
                </ul>
            <li>Il permet de découpler l’émetteur d’une commande (AdminController) de son exécution réelle (implémentée dans les classes Command), en suivant le principe de responsabilité unique.</li>
            <li>Il est aussi très utile pour implémenter des fonctionnalités d'annulation ou d'historique, comme c'est le cas ici avec Invoker.undo().</li>
            <li>Nous avons choisie de representer uniquement l'option Create (Edit et Delete on ete omis) afin de simplifier le diagramme de sequence.</li>
        </ul>

    <u><h2>Visiteur</h2></u>
    <p>
        <a href="Design/Visitor.vpp" alt="visitorVPP">Diagramme de classe : visiteur</a> <br>
        <img src="images/Visitor.jpg" alt="visitVPPimg">
        <br>
        <a href="Design/VisitorSequence.vpp" alt="visitorSequenceVPP">Diagramme de sequence : visiteur</a> <br>
        <img src="images/VisitorSequence.jpg" alt="visitorSequenceVPPimg">
        <br>
        Voici quelques hypothèses et notre raisonnement :
    </p>
        <ul>
            <li>Le patron Visiteur permet d’introduire de nouvelles opérations sur des objets existants tels que AdminTripVisitor et ClientTripVisitor, qui sont appliquées à des objets de type Itinerary sans modifier leur structure interne, tout en respectant le principe OCP.</li>
            <li>En général, ce patron est composé d’une interface IVisitor qui définit la méthode visit() pour les types d’objets qu’on veut parcourir, d’une ou plusieurs classes concrètes comme AdminTripVisitor ou ClientTripVisitor qui implémentent chacune leur propre logique, et d’une interface IVisitable (comme ici Itinerary) qui permet à l’objet de recevoir un visiteur via la méthode acceptVisitor(IVisitor).</li>
            <li>Itinerary est l'élément concrèt à visiter</li>
            <li>AdminTripVisitor et ClientTripVisitor sont les deux visiteurs concrèts</li>
            <li>La structure de donnée implémentée pour les itinéraire est ArrayList&lt;Itinerary&gt;. C'est pourquoi la boucle pour accepter la visite pour chaque itinéraire de la liste.</li>
        </ul>

    <u><h2>Strategie</h2></u>
    <p>
        <a href="Design/Strategy.vpp" alt="startegyVPP">Diagramme de classe : strategie</a> <br>
        <img src="images/Strategy.jpg" alt="strategyVPPimg">
        <br>
        Voici quelques hypothèses et notre raisonnement :
    </p>    
        <ul>
            <li>Nous avons décidé d'implémenter le patron Stratégie pour encapsuler les modes de paiement. Ceci permettrait au code d'être plus flexible s'il y a ajout d'autres modes de paiement. (OCP)</li>
            <li>Chaque stratégie implémente sa propre version des méthodes pay(amount) et setPaymentDetails(), ce qui permet de changer dynamiquement la méthode de paiement sans modifier la classe Transaction.</li>
            <li>Transaction joue le rôle de contexte : elle délègue l’exécution de l’opération à l’objet PayStrategy qu’elle reçoit en paramètre via la méthode process().</li>
        </ul>   

    <u><h2>Memento</h2></u>
    <p>
        <a href="Design/Memento.vpp" alt="mementoVPP">Diagramme de classe : memento</a> <br>
        <img src="images/Memento.jpg" alt="mementoVPPimg">
        <br>
        Voici quelques hypothèses et notre raisonnement :
    </p>    
        <ul>
            <li>Nous avons décidé d'implémenter le patron Memento avec le patron Commande pour permettre de sauvegarder l'état du Repository avant l'exécution d'une commande. Ceci permettrait d'annuler ou restaurer l'état en cas de undo().</li>
            <li>Repository joue le rôle de Originator : il peut créer un objet Memento contenant une copie de son état (companies, vehicles, itineraries, etc.) grâce à la méthode saveState().</li>
            <li>La classe Invoker agit comme Caretaker : elle sauvegarde les états dans une pile (mementoHistory) via save(), et peut restaurer un état précédent avec restore().</li>
        </ul>
    
    <u><h2>Qualité de notre conception amélioré</h2></u> 
    <p>Dans le DM2, le système se basait principalement sur une architecture MVC, ce qui offrait une séparation des données, la logique de contrôle et l'interface. Cependant, l'implémentation ne suffisait pas à assurer la flexibilité, réutilisabilité et maintenabilité du code. Le DM3 a introduit plusieurs patrons de conception pour améliorer la qualité de notre conception.</p>   
        <ul>
            <li>Plusieurs classes (notamment Client et Administrator) violaient initialement le principe de responsabilité unique (SRP). Le nouveau design introduit une séparation claire des responsabilités, grâce à une meilleure application du modèle MVC et à l’intégration du patron Observer. Chaque classe remplit désormais un rôle précis : les vues sont responsables de l’interaction avec l’utilisateur, les contrôleurs centralisent la logique métier, et les modèles (comme Repository) gèrent les données.</li>
            <li>Les modifications apportées permettent également de mieux découpler les composants, en particulier grâce à l’Observer, qui assure une synchronisation automatique entre les données et les interfaces graphiques sans dépendance directe. Toutes les actions possibles — qu’elles soient initiées par l’utilisateur ou déclenchées par des événements — passent désormais par les contrôleurs, ce qui améliore la cohérence, la maintenabilité et la testabilité de l’application.</li>
            <li>L'utilisation du patron d'Observateur en plus de l'utilisation du Singleton Repository  garantit un point de référence des données centralisé et cohérent entre les différentes vues, créant une meilleur cohésion ainsi qu'un couplage faible en comparaison avec le devoir 2 ou plusieurs entités différentes accedait ou modifiait les données. Cette nouvelle version permet aux utilisateurs de s'abonner au repository et d'être automatiquement notifié lors de changements. </li>
        </ul>
    <p>En conclusion, par l'introduction et combinaisons de plusieurs patrons de conception et l'application des principes de conception, le DM3 a permis d'améliorer considérablement la qualité de notre conception du système de voyage. Ces changements rendent le code plus modulaire, extensible et maintenable, tout en respectant les principes SOLID.</p>
            
    <div id="shimeji-workArea"
      style="position: fixed; background: transparent; z-index: 2147483643; width: 100vw; height: 100vh; left: 0px; top: 0px; transform: translate(0px, 0px); pointer-events: none;">
    </div>
    </body>
  
</html>